import javassist.bytecode.ClassFile
import javassist.bytecode.MethodInfo

import org.gradle.api.tasks.testing.logging.TestExceptionFormat

import java.nio.file.Files
import java.nio.file.StandardCopyOption

import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Path;

import org.apache.tools.ant.filters.ReplaceTokens

import org.objectweb.asm.ClassReader
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.Opcodes
import org.objectweb.asm.tree.AnnotationNode
import org.objectweb.asm.tree.ClassNode
import org.objectweb.asm.tree.MethodNode
import org.objectweb.asm.tree.FieldNode

import java.util.jar.JarFile;

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'org.javassist:javassist:3.30.2-GA'

        classpath 'org.ow2.asm:asm:9.9.1'
        classpath 'org.ow2.asm:asm-tree:9.9.1'
        classpath 'org.ow2.asm:asm-commons:9.9.1'
    }
}

plugins {
    id 'fabric-loom' version "${loom_version}"
    id 'maven-publish'
}

version = project.mod_version
group = project.maven_group

base {
    archivesName = project.archives_base_name
}

repositories {
    // Add repositories to retrieve artifacts from in here.
    // You should only use this when depending on other mods because
    // Loom adds the essential maven repositories to download Minecraft and libraries from automatically.
    // See https://docs.gradle.org/current/userguide/declaring_repositories.html
    // for more information about repositories.
    maven {
        url = 'https://maven.shedaniel.me/'
        content {
            includeGroup 'me.shedaniel.cloth'
        }
    }

    maven {
        url = 'https://maven.terraformersmc.com/releases/'
        content {
            includeGroup 'com.terraformersmc'
        }
    }

    maven {
        url = 'https://repo.hypixel.net/repository/Hypixel/'
        content {
            includeGroup 'net.hypixel'
        }
    }
}

loom {
    mods {
        'darkutils' {
            sourceSet sourceSets.main
        }
    }

    decompilers {
        vineflower {
            // Makes lambda names easy to find for Mixins
            options.put('mark-corresponding-synthetics', '1')
        }
    }
}

dependencies {
    // To change the versions see the gradle.properties file
    minecraft "com.mojang:minecraft:${project.minecraft_version}"
    mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
    //mappings loom.officialMojangMappings()
    modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

    // Fabric API. This is technically optional, but you probably want it anyway.
    modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"

    modApi('me.shedaniel.cloth:cloth-config-fabric:21.11.153') {
        exclude(group: 'net.fabricmc.fabric-api')
    }

    modApi('com.terraformersmc:modmenu:17.0.0-beta.2') {
        exclude(group: 'net.fabricmc.fabric-api')
    }

    modApi('net.hypixel:mod-api:1.0.1') {
        exclude(group: 'net.fabricmc.fabric-api')
    }

    testImplementation('org.junit.jupiter:junit-jupiter:6.1.0-M1')
    testImplementation('org.junit.jupiter:junit-jupiter-api:6.1.0-M1')

    testRuntimeOnly('org.junit.platform:junit-platform-launcher:6.1.0-M1')

    compileOnly('com.google.errorprone:error_prone_annotations:2.47.0')
}

tasks {
    test {
        useJUnitPlatform()

        testLogging {
            exceptionFormat = TestExceptionFormat.FULL
            showStandardStreams = true
        }
    }
}

configurations {
    testImplementation.extendsFrom compileOnly
}

tasks.withType(Test).configureEach {
    reports {
        html.required = false
        junitXml.required = false
    }

    it.systemProperty('inside.junit', 'true');
}

processResources {
    // Capture version at configuration time
    final def modVersion = project.version

    // Declare version for incremental builds
    inputs.property('version', modVersion)

    filesMatching('fabric.mod.json') {
        expand(['version': modVersion])
    }
}

tasks.register('preprocessMixinNames', Copy) {
    from(layout.projectDirectory.dir('src/main/java'))
    into(layout.buildDirectory.dir('preprocessed/java'))

    include('**/*.java')

    // declare file names as task inputs for cache correctness
    inputs.files(
        fileTree('src/main/java') {
            include('**/mixin/**/*.java')
        }
    ).withPropertyName('mixinSources')
     .withPathSensitivity(PathSensitivity.RELATIVE)

    filesMatching('**/mixin/**/*.java') {
        final def name = it.name.substring(0, it.name.lastIndexOf('.'))

        // create a per-file filter instance
        it.filter(ReplaceTokens, tokens: [
            fileName: name
        ])
    }
}

tasks.named('compileJava', JavaCompile).configure {
    dependsOn(tasks.named('preprocessMixinNames'))
    source = layout.buildDirectory.dir('preprocessed/java').map {
        fileTree(it)
    }
}

tasks.withType(JavaCompile).configureEach {
    it.options.release = 21
    it.options.compilerArgs += '-Xlint:all'

    it.options.compilerArgs += '-g'
    it.options.compilerArgs += '-parameters'
}

tasks.named('jar', Jar) {
    manifest {
        attributes(
                'Multi-Release': 'true',
                'Sealed': 'true',
                'Main-Class': 'gg.darkutils.DarkUtils',
                'Automatic-Module-Name': 'gg.darkutils',
                'Specification-Title': 'DarkUtils',
                'Specification-Version': project.version.toString(),
                'Specification-Vendor': 'DarkUtils',
                'Implementation-Title': 'DarkUtils',
                'Implementation-Version': project.version.toString(),
                'Implementation-Vendor': 'DarkUtils',
                'Name': 'gg/darkutils/'
        )
    }
}

java {
    // Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
    // if it is present.
    // If you remove this line, sources will not be generated.
    withSourcesJar()

    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

jar {
    inputs.property 'archivesName', project.base.archivesName
    final def archiveName = inputs.properties.archivesName

    from('LICENSE') {
        rename { "${it}_${archiveName}" }
    }
}

// configure the maven publication
publishing {
    publications {
        create('mavenJava', MavenPublication) {
            artifactId = project.archives_base_name
            from components.java
        }
    }

    // See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
    repositories {
        // Add repositories to publish to here.
        // Notice: This block does NOT have the same function as the block in the top level.
        // The repositories here will be used for publishing your artifact, not for
        // retrieving dependencies.
    }
}

@CacheableTask
abstract class AsmPreprocessTask extends DefaultTask {
    static final def NAME_DESC               = 'Lgg/darkutils/annotations/Name;'
    static final def SYNTHETIC_DESC          = 'Lgg/darkutils/annotations/Synthetic;'
    static final def BRIDGE_DESC             = 'Lgg/darkutils/annotations/Bridge;'
    static final def PRIVATE_DESC            = 'Lgg/darkutils/annotations/Private;'
    static final def PACKAGE_PRIVATE_DESC    = 'Lgg/darkutils/annotations/PackagePrivate;'
    static final def PRIVATE_FIELDS_DESC     = 'Lgg/darkutils/annotations/PrivateFields;'

    static final def MIXIN_OVERWRITE_DESC    = 'Lorg/spongepowered/asm/mixin/Overwrite;'

    @InputDirectory
    @PathSensitive(PathSensitivity.RELATIVE)
    abstract DirectoryProperty getInputClassesDir()

    @Classpath
    public abstract ConfigurableFileCollection getProcessorClasspath()

    @OutputDirectory
    abstract DirectoryProperty getOutputClassesDir()

    @Inject
    protected abstract FileSystemOperations getFs()

    private final void copyFile(final File from, final File to) {
        getFs().copy {
            it.from(from)
            it.into(to.parentFile)

            it.rename { to.name }
        }
    }

    private static final boolean overridesSomething(final ClassNode owner, final MethodNode method, final Set<File> classpath) {
        final def name = method.name
        final def desc = method.desc

        return AsmPreprocessTask.hierarchyHasMethod(owner, name, desc, classpath)
    }

    private static final boolean hierarchyHasMethod(final ClassNode owner, final String name, final String desc, final Set<File> classpath) {
        final def queue   = new ArrayDeque<String>()
        final def visited = new HashSet<String>()

        if (null != owner.superName) {
            queue.add(owner.superName)
        }

        queue.addAll(owner.interfaces)

        while (!queue.isEmpty()) {
            final def internalName = queue.removeFirst()

            if (!visited.add(internalName)) {
                continue
            }

            final def cn = AsmPreprocessTask.loadClassNode(internalName, classpath)

            if (null == cn) {
                //System.err.println("Failed to load class: $internalName from classpath")
                continue
            }

            for (final def m : cn.methods) {
                if (m.name == name && m.desc == desc) {
                    return true
                }
            }

            if (null != cn.superName) {
                queue.add(cn.superName)
            }

            queue.addAll(cn.interfaces)
        }

        return false
    }

    private static final ClassNode loadClassNode(final String internalName, final Set<File> classpath) {
        final def entry = internalName + '.class'

        for (final def root : classpath) {
            if (root.isDirectory()) {
                final def file = new File(root, entry)

                if (!file.exists()) {
                    continue
                }

                return AsmPreprocessTask.readNode(file.bytes)
            }

            if (root.name.endsWith('.jar')) {
                new JarFile(root).withCloseable { jar ->
                    final def e = jar.getJarEntry(entry)

                    if (null != e) {
                        return AsmPreprocessTask.readNode(jar.getInputStream(e).bytes)
                    }
                }
            }
        }

        /*
         * ---------- JDK MODULE FALLBACK ----------
         */

        final FileSystem jrt = FileSystems.getFileSystem(URI.create('jrt:/'))
        final Path modules = jrt.getPath('/modules')

        try (final def stream = Files.walk(modules)) {
            final def found = stream.filter { it.toString().endsWith(entry) }.findFirst()

            if (found.isPresent()) {
                return AsmPreprocessTask.readNode(Files.readAllBytes(found.get()))
            }
        }

        return null
    }

    private static final ClassNode readNode(final byte[] bytes) {
        final def cr = new ClassReader(bytes)
        final def cn = new ClassNode()

        cr.accept(cn, ClassReader.SKIP_CODE)

        return cn
    }

    private static final boolean hasAnnotation(final MethodNode mn, final String desc) {
        final def anns = mn.visibleAnnotations

        if (null != anns) {
            for (final def a : anns) {
                if (a.desc == desc) {
                    return true
                }
            }
        }

        final def ianns = mn.invisibleAnnotations

        if (null != ianns) {
            for (final def a : ianns) {
                if (a.desc == desc) {
                    return true
                }
            }
        }

        return false
    }

    private static final String methodAccessToString(final MethodNode method) {
        final def flags = []
        if ((method.access & Opcodes.ACC_PUBLIC) != 0) flags << 'public'
        if ((method.access & Opcodes.ACC_PRIVATE) != 0) flags << 'private'
        if ((method.access & Opcodes.ACC_PROTECTED) != 0) flags << 'protected'
        if ((method.access & Opcodes.ACC_STATIC) != 0) flags << 'static'
        if ((method.access & Opcodes.ACC_FINAL) != 0) flags << 'final'
        if ((method.access & Opcodes.ACC_SYNCHRONIZED) != 0) flags << 'synchronized'
        if ((method.access & Opcodes.ACC_BRIDGE) != 0) flags << 'bridge'
        if ((method.access & Opcodes.ACC_VARARGS) != 0) flags << 'varargs'
        if ((method.access & Opcodes.ACC_NATIVE) != 0) flags << 'native'
        if ((method.access & Opcodes.ACC_ABSTRACT) != 0) flags << 'abstract'
        if ((method.access & Opcodes.ACC_STRICT) != 0) flags << 'strictfp'
        if ((method.access & Opcodes.ACC_SYNTHETIC) != 0) flags << 'synthetic'
        return flags.join(' ')
    }

    @TaskAction
    final void run() {
        final File inputDir = getInputClassesDir().get().asFile
        final File outputDir = getOutputClassesDir().get().asFile

        getFs().delete {
            it.delete(outputDir)
        }

        inputDir.eachFileRecurse { final File inputFile ->
            if (!inputFile.isFile()) {
                return
            }

            final def relative = inputDir.toPath().relativize(inputFile.toPath())
            final File outputFile = new File(outputDir, relative.toString())

            /*
             * Non-class files must be copied as-is
             */
            if (!inputFile.name.endsWith('.class')) {
                getFs().copy {
                    it.from(inputFile)
                    it.into(outputFile.parentFile)
                    it.rename { outputFile.name }
                }
                return
            }

            final def bytes = inputFile.bytes

            final def cr = new ClassReader(bytes)
            final def cn = new ClassNode()

            cr.accept(cn, ClassReader.EXPAND_FRAMES)

            def changed = false
            def renamed = false

            final def classPublic = 0 != (cn.access & Opcodes.ACC_PUBLIC)

            /*
             * -----------------------------
             * CLASS PROCESSING
             * -----------------------------
             */
            if (0 != (cn.access & Opcodes.ACC_SYNTHETIC)) {
                changed = true
                cn.access |= Opcodes.ACC_FINAL
                //logger.lifecycle("Made ${cn.name} final")
            }

            if (!classPublic) {
                for (final def fn : cn.fields) {
                    if (0 != (fn.access & Opcodes.ACC_PUBLIC)) {
                        changed = true
                        fn.access &= ~Opcodes.ACC_PUBLIC
                        //logger.lifecycle("Removed public from field ${cn.name}#${fn.name}")
                    }

                    if (0 != (fn.access & Opcodes.ACC_PROTECTED)) {
                        changed = true
                        fn.access &= ~Opcodes.ACC_PROTECTED
                        //logger.lifecycle("Removed protected from field ${cn.name}#${fn.name}")
                    }
                }

                for (final def mn : cn.methods) {
                    if ('<clinit>' == mn.name || '<init>' == mn.name || 0 != (mn.access & Opcodes.ACC_PRIVATE) || AsmPreprocessTask.hasAnnotation(mn, MIXIN_OVERWRITE_DESC)) {
                        continue
                    }

                    if (0 == (mn.access & Opcodes.ACC_STATIC) && AsmPreprocessTask.overridesSomething(cn, mn, getProcessorClasspath().getFiles())) {
                        continue
                    }

                    if (0 == (mn.access & Opcodes.ACC_BRIDGE) && mn.name.contains('mixin')) {
                        logger.warn("Method ${cn.name}#${mn.name} should be package-private or private")
                    }

                    if (0 != (mn.access & Opcodes.ACC_PUBLIC) && 0 == (mn.access & Opcodes.ACC_BRIDGE) && 0 == (cn.access & Opcodes.ACC_INTERFACE)) {
                        changed = true
                        mn.access &= ~Opcodes.ACC_PUBLIC
                        //logger.lifecycle("Removed public from method ${cn.name}#${mn.name}")
                    }

                    if (0 != (mn.access & Opcodes.ACC_PROTECTED) && 0 == (mn.access & Opcodes.ACC_BRIDGE)) {
                        changed = true
                        mn.access &= ~Opcodes.ACC_PROTECTED
                        //logger.lifecycle("Removed protected from method ${cn.name}#${mn.name}")
                    }
                }
            } else if (cn.name.contains('mixin') && !cn.name.contains('accessor')) {
                logger.warn('Non-accessor mixin class declared public')
            }

            /*
             * -----------------------------
             * METHOD PROCESSING
             * -----------------------------
             */
            final def isInterface = 0 != (cn.access & Opcodes.ACC_INTERFACE)
            final def isRecord = 0 != (cn.access & Opcodes.ACC_RECORD)

            final def clsAnns = cn.invisibleAnnotations

            def privateFields = false

            if (null != clsAnns) {
                for (final def an : clsAnns) {
                    if (PRIVATE_FIELDS_DESC == an.desc) {
                        privateFields = true
                    } else if (SYNTHETIC_DESC == an.desc) {
                        changed = true
                        cn.access |= Opcodes.ACC_SYNTHETIC
                        //logger.lifecycle("Added ACC_SYNTHETIC to ${cn.name}")
                    } else if (PACKAGE_PRIVATE_DESC == an.desc) {
                        changed = true
                        cn.access &= ~Opcodes.ACC_PUBLIC
                        cn.access &= ~Opcodes.ACC_PROTECTED
                        //logger.lifecycle("Added package-private to ${cn.name}")
                    } else if (PRIVATE_DESC == an.desc) {
                        changed = true
                        cn.access &= ~Opcodes.ACC_PUBLIC
                        cn.access &= ~Opcodes.ACC_PROTECTED
                        cn.access |= Opcodes.ACC_PRIVATE
                        //logger.lifecycle("Added private to ${cn.name}")
                    } else if (NAME_DESC == an.desc) {
                        final def vals = an.values

                        for (def i = 0; i < vals.size(); i += 2) {
                            if ('value' != vals.get(i)) {
                                continue
                            }

                            final def oldName = mn.name
                            final def newName = vals.get(i + 1)

                            if (oldName != newName) {
                                changed = true
                                cn.name = newName
                                //logger.lifecycle("Renamed ${oldName} into ${cn.name}")
                            }
                        }
                    }
                }
            }

            for (final def fn : cn.fields) {
                final def fnAnns = fn.invisibleAnnotations

                for (final def an : fnAnns) {
                    if (SYNTHETIC_DESC == an.desc) {
                        changed = true
                        fn.access |= Opcodes.ACC_SYNTHETIC
                        //logger.lifecycle("Added ACC_SYNTHETIC to ${cn.name}#${fn.name}")
                    } else if (PACKAGE_PRIVATE_DESC == an.desc) {
                        changed = true
                        fn.access &= ~Opcodes.ACC_PUBLIC
                        fn.access &= ~Opcodes.ACC_PROTECTED
                        //logger.lifecycle("Added package-private to ${cn.name}#${fn.name}")
                    } else if (PRIVATE_DESC == an.desc) {
                        changed = true
                        fn.access &= ~Opcodes.ACC_PUBLIC
                        fn.access &= ~Opcodes.ACC_PROTECTED
                        fn.access |= Opcodes.ACC_PRIVATE
                        //logger.lifecycle("Added private to ${cn.name}#${fn.name}")
                    } else if (NAME_DESC == an.desc) {
                        final def vals = an.values

                        for (def i = 0; i < vals.size(); i += 2) {
                            if ('value' != vals.get(i)) {
                                continue
                            }

                            final def oldName = mn.name
                            final def newName = vals.get(i + 1)

                            if (oldName != newName) {
                                changed = true
                                fn.name = newName
                                //logger.lifecycle("Renamed ${cn.name}#${oldName} into ${cn.name}#${fn.name}")
                            }
                        }
                    }
                }
            }

            if (privateFields) {
                for (final def fn : cn.fields) {
                    if (0 != (fn.access & Opcodes.ACC_PUBLIC)) {
                        changed = true
                        fn.access &= ~Opcodes.ACC_PUBLIC
                        //logger.lifecycle("Removed public from field ${cn.name}#${fn.name}")
                    }

                    if (0 != (fn.access & Opcodes.ACC_PROTECTED)) {
                        changed = true
                        fn.access &= ~Opcodes.ACC_PROTECTED
                        //logger.lifecycle("Removed protected from field ${cn.name}#${fn.name}")
                    }

                    if (0 == (fn.access & Opcodes.ACC_PRIVATE)) {
                        changed = true
                        fn.access |= Opcodes.ACC_PRIVATE
                        //logger.lifecycle("Add private to field ${cn.name}#${fn.name}")
                    }
                }
            }

            for (final def mn : cn.methods) {
                /*
                 * FINALIZATION
                 */
                final def abstractMethod = 0 != (mn.access & Opcodes.ACC_ABSTRACT)

                if (!isInterface && !abstractMethod && '<clinit>' != mn.name && '<init>' != mn.name && 0 == (mn.access & Opcodes.ACC_FINAL)) {
                    if ((isRecord || 0 != (mn.access & Opcodes.ACC_BRIDGE) || 0 != (mn.access & Opcodes.ACC_SYNTHETIC) || mn.name.contains('$') || 'values' == mn.name || 'valueOf' == mn.name)) {
                        changed = true
                        mn.access |= Opcodes.ACC_FINAL
                        if (!isRecord && 0 == (mn.access & Opcodes.ACC_BRIDGE) && 0 == (mn.access & Opcodes.ACC_SYNTHETIC) && 'values' != mn.name && 'valueOf' != mn.name) {
                            logger.warn("Method ${cn.name}#${mn.name} should be final")
                        }
                        //logger.lifecycle("Added final to ${cn.name}#${mn.name}")
                    } else {
                        logger.warn("Method ${cn.name}#${mn.name} should be final")
                    }
                }

                /*
                 * METHOD ANNOTATIONS
                 */
                final def anns =
                        mn.invisibleAnnotations

                if (null != anns) {
                    for (final def an : anns) {
                        if (NAME_DESC == an.desc) {
                            final def vals = an.values

                            for (def i = 0; i < vals.size(); i += 2) {
                                if ('value' != vals.get(i)) {
                                    continue
                                }

                                final def oldName = mn.name
                                final def newName = vals.get(i + 1)

                                if (oldName != newName) {
                                    changed = true
                                    renamed = true
                                    mn.name = newName
                                    //logger.lifecycle("Renamed ${cn.name}#${oldName} into ${cn.name}#${mn.name}")
                                }
                            }
                        }

                        if (SYNTHETIC_DESC == an.desc) {
                            changed = true
                            mn.access |= Opcodes.ACC_SYNTHETIC
                            //logger.lifecycle("Added ACC_SYNTHETIC to ${cn.name}#${mn.name}")
                        }

                        if (PACKAGE_PRIVATE_DESC == an.desc && 0 == (mn.access & Opcodes.ACC_BRIDGE)) {
                            changed = true
                            mn.access &= ~Opcodes.ACC_PUBLIC
                            mn.access &= ~Opcodes.ACC_PROTECTED
                            //logger.lifecycle("Made method package-private: ${cn.name}#${mn.name}")
                        }

                        if (PRIVATE_DESC == an.desc && 0 == (mn.access & Opcodes.ACC_BRIDGE)) {
                            changed = true
                            mn.access &= ~Opcodes.ACC_PUBLIC
                            mn.access &= ~Opcodes.ACC_PROTECTED
                            mn.access |= Opcodes.ACC_PRIVATE
                            //logger.lifecycle("Made method private: ${cn.name}#${mn.name}")
                        }

                        if (BRIDGE_DESC == an.desc) {
                            changed = true
                            mn.access |= Opcodes.ACC_BRIDGE
                            //logger.lifecycle("Added ACC_BRIDGE to ${cn.name}#${mn.name}")
                        }
                    }
                }

                /*if (0 != (mn.access & Opcodes.ACC_BRIDGE) || 0 != (mn.access & Opcodes.ACC_SYNTHETIC)) {
                    def mod = AsmPreprocessTask.methodAccessToString(mn)
                    mod += " ${cn.name}.${mn.name}()"

                    logger.lifecycle(mod)
                }*/
            }

            def output = bytes

            if (changed) {
                def cw = new ClassWriter(0)

                if (renamed) {
                    cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS) {
                        @Override
                        protected final String getCommonSuperClass(final String type1, final String type2) {
                            return 'java/lang/Object'
                        }
                    }
                }

                cn.accept(cw)

                output = cw.toByteArray()
            }

            if (!changed) {
                getFs().copy {
                    it.from(inputFile)
                    it.into(outputFile.parentFile)
                    it.rename { outputFile.name }
                }
                return
            }

            outputFile.parentFile.mkdirs() // allowed here: we're writing declared @OutputDirectory

            outputFile.newOutputStream().withCloseable {
                it.write(output)
            }
        }
    }
}

tasks.register('asmPreprocess', AsmPreprocessTask) {
    inputClassesDir.set(tasks.named('compileJava', JavaCompile).flatMap { it.destinationDirectory })
    outputClassesDir.set(layout.buildDirectory.dir('asmProcessedClasses'))
}

tasks.named('asmPreprocess', AsmPreprocessTask).configure {
    processorClasspath.from(sourceSets.main.runtimeClasspath)
}

final def compileOutputDirProvider = tasks.named('compileJava', JavaCompile).flatMap(JavaCompile::getDestinationDirectory)
final def asmOutputProvider = tasks.named('asmPreprocess').flatMap(AsmPreprocessTask::getOutputClassesDir)

tasks.named('jar', Jar).configure { jarTask ->
    dependsOn(tasks.named('asmPreprocess'))

    // include ASM-processed classes
    from(asmOutputProvider)

    // exclude ORIGINAL compiled classes from jar
    exclude { details ->
        final def compileDir = compileOutputDirProvider.get().asFile.toPath()
        final def filePath = details.file.toPath()

        return filePath.startsWith(compileDir)
    }
}

// Task class for full configuration-cache compatibility
@CacheableTask
abstract class CheckMethodSizesTask extends DefaultTask {
    @CompileClasspath
    @InputFiles
    abstract ConfigurableFileCollection getClassesDirectories()

    @OutputFile
    abstract RegularFileProperty getReportFile()

    @TaskAction
    final void checkMethods() {
        final def thresholds = [huge: 8000, large: 2000, nonsmall: 325]
        final def issues = []

        getClassesDirectories().each { final File directory ->
            if (!directory.exists()) return

            directory.eachFileRecurse { final File file ->
                if (!file.name.endsWith('.class')) return

                final def relativePath = directory.toPath().relativize(file.toPath()).toString()
                final def className = relativePath.replace(File.separator, '.').replaceAll('[.]class$', '')

                file.withInputStream { final inputStream ->
                    new DataInputStream(inputStream).withCloseable { final dataInputStream ->
                        final def classFile = new ClassFile(dataInputStream)
                        classFile.methods.each { final MethodInfo methodInfo ->
                            final def codeAttribute = methodInfo.codeAttribute
                            if (codeAttribute == null) return
                            final def size = codeAttribute.code.length

                            if (size > thresholds.huge) issues << "Huge method: $className#${methodInfo.name} (bytecode size: $size)"
                            else if (size > thresholds.large) issues << "Large method: $className#${methodInfo.name} (bytecode size: $size)"
                            else if (size > thresholds.nonsmall) issues << "Non trivial method: $className#${methodInfo.name} (bytecode size: $size)"
                        }
                    }
                }
            }
        }

        final def report = getReportFile().get().asFile
        report.parentFile.mkdirs()
        report.text = issues.join('\n')

        if (issues.empty) {
            println 'All methods are within size thresholds.'
        } else {
            println 'Method size issues found:'
            issues.each { println it }
            println "Method size check: ${issues.size()} issues"
        }
    }
}

// Register the task in a configuration-cache-safe way
tasks.register('checkMethodSizes', CheckMethodSizesTask) {
    group = 'verification'
    description = 'Checks bytecode sizes of compiled methods.'

    // Use a FileCollection as input (lazy, configuration-cache safe)
    classesDirectories.from(
        layout.buildDirectory.dir('classes/java/main')
    )

    reportFile.set(
        layout.buildDirectory.file('reports/methodSizes.txt')
    )

    dependsOn tasks.named('classes')
}

// Make it run after asmPreprocess
tasks.named('asmPreprocess') {
    finalizedBy tasks.named('checkMethodSizes')
}

static final Provider<File> resolveMinecraftDir(Project project) {
    final def providers = project.providers
    final def layout = project.layout

    final def devPropsFile = layout.projectDirectory.file('dev.properties')

    final def fromProps =
            providers.fileContents(devPropsFile)
                    .asText
                    .map { text ->
                        final def props = new Properties()
                        props.load(new StringReader(text))
                        props.getProperty('minecraftDir')
                    }

    final def envFile = layout.projectDirectory.file('.env')

    final def fromEnv =
            providers.fileContents(envFile)
                    .asText
                    .map { text ->
                        text.readLines()
                                .find { it.startsWith('MINECRAFT_DIR=') }
                                ?.split('=', 2)
                                ?.getAt(1)
                    }

    final def defaultDir =
            providers.systemProperty('user.home')
                    .map { it + '/.minecraft' }

    final def finalPath =
            fromProps
                    .orElse(fromEnv)
                    .orElse(defaultDir)

    return finalPath.map { new File(it) }
}

abstract class InstallToModFolderTask extends DefaultTask {
    @Classpath
    @InputFile
    abstract RegularFileProperty getInputJar()

    @Input
    abstract Property<String> getModVersion()

    @OutputDirectory
    abstract DirectoryProperty getTargetModsDir()

    @Inject
    abstract FileSystemOperations getFs()

    @TaskAction
    final void install() {
        final def input = getInputJar().get().asFile.toPath()
        final def modsDir = getTargetModsDir().get().asFile.toPath()

        if (!Files.exists(modsDir)) return

        final def fileName = input.fileName.toString()
        final def baseName =
                fileName.replaceFirst("-${getModVersion().get()}\\.jar\$", '')

        // Delete previous versions of this mod
        Files.list(modsDir)
                .filter { it.fileName.toString().startsWith(baseName + '-') }
                .filter { it.fileName.toString().endsWith('.jar') }
                .forEach {
                    logger.lifecycle("Removing old mod jar: ${it.fileName}")
                    Files.deleteIfExists(it)
                }

        final def target = modsDir.resolve(fileName)

        Files.copy(
                input,
                target,
                StandardCopyOption.REPLACE_EXISTING
        )

        logger.lifecycle('DarkUtils jar installed successfully:')
        logger.lifecycle("${fileName} -> ${modsDir}")
        logger.lifecycle('')
        logger.lifecycle('You do not need to copy manually to your mod folder.')
    }
}

tasks.register('installToModFolder', InstallToModFolderTask) {
    dependsOn tasks.named('remapJar')

    inputJar.set(
        tasks.named('remapJar').flatMap { it.archiveFile }
    )

    modVersion.set(project.version.toString())

    targetModsDir.set(
            project.layout.dir(
                    resolveMinecraftDir(project)
                            .map { new File(it, 'mods') }
            )
    )
}

tasks.named('checkMethodSizes') {
    finalizedBy tasks.named('installToModFolder')
}

tasks.named('installToModFolder', InstallToModFolderTask).configure {
    onlyIf(new Spec<Task>() {
        @Override
        final boolean isSatisfiedBy(final Task t) {
            final def dir = ((InstallToModFolderTask) t)
                    .getTargetModsDir()
                    .getOrNull()

            return null == System.getenv('CI') &&
                   null != dir &&
                   dir.getAsFile().exists()
        }
    })
}

