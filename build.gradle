import javassist.bytecode.ClassFile
import javassist.bytecode.MethodInfo

import org.gradle.api.specs.Spec
import org.gradle.api.DefaultTask
import org.gradle.api.provider.Provider
import org.gradle.api.provider.Property
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.file.Directory
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.tasks.CacheableTask
import org.gradle.api.tasks.CompileClasspath
import org.gradle.api.tasks.Classpath
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.PathSensitive
import org.gradle.api.tasks.PathSensitivity
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.file.FileSystemOperations

import javax.inject.Inject

import java.io.StringReader

import java.nio.file.Path
import java.nio.file.Paths
import java.nio.file.Files
import java.nio.file.StandardCopyOption

import java.util.Properties

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'org.javassist:javassist:3.30.2-GA'
    }
}

plugins {
    id 'fabric-loom' version "${loom_version}"
    id 'maven-publish'
}

version = project.mod_version
group = project.maven_group

base {
    archivesName = project.archives_base_name
}

repositories {
    // Add repositories to retrieve artifacts from in here.
    // You should only use this when depending on other mods because
    // Loom adds the essential maven repositories to download Minecraft and libraries from automatically.
    // See https://docs.gradle.org/current/userguide/declaring_repositories.html
    // for more information about repositories.
    maven {
        url = 'https://maven.shedaniel.me/'
        content {
            includeGroup 'me.shedaniel.cloth'
        }
    }

    maven {
        url = 'https://maven.terraformersmc.com/releases/'
        content {
            includeGroup 'com.terraformersmc'
        }
    }

    maven {
        url = 'https://repo.hypixel.net/repository/Hypixel/'
        content {
            includeGroup 'net.hypixel'
        }
    }
}

loom {
    mods {
        'darkutils' {
            sourceSet sourceSets.main
        }
    }

    decompilers {
        vineflower {
            // Makes lambda names easy to find for Mixins
            options.put('mark-corresponding-synthetics', '1')
        }
    }
}

dependencies {
    // To change the versions see the gradle.properties file
    minecraft "com.mojang:minecraft:${project.minecraft_version}"
    mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
    //mappings loom.officialMojangMappings()
    modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

    // Fabric API. This is technically optional, but you probably want it anyway.
    modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"

    modApi('me.shedaniel.cloth:cloth-config-fabric:21.11.153') {
        exclude(group: 'net.fabricmc.fabric-api')
    }

    modApi('com.terraformersmc:modmenu:17.0.0-beta.2') {
        exclude(group: 'net.fabricmc.fabric-api')
    }

    modApi('net.hypixel:mod-api:1.0.1') {
        exclude(group: 'net.fabricmc.fabric-api')
    }

    testImplementation('org.junit.jupiter:junit-jupiter:6.1.0-M1')
    testImplementation('org.junit.jupiter:junit-jupiter-api:6.1.0-M1')

    testRuntimeOnly('org.junit.platform:junit-platform-launcher:6.1.0-M1')
}

tasks {
    test {
        useJUnitPlatform()

        testLogging {
            exceptionFormat = TestExceptionFormat.FULL
            showStandardStreams = true
        }
    }
}

configurations {
    testImplementation.extendsFrom compileOnly
}

tasks.withType(Test).configureEach {
    reports {
        html.required = false
        junitXml.required = false
    }

    it.systemProperty('inside.junit', 'true');
}

processResources {
    // Capture version at configuration time
    final def modVersion = project.version

    // Declare version for incremental builds
    inputs.property('version', modVersion)

    filesMatching('fabric.mod.json') {
        expand(["version": modVersion])
    }
}

tasks.withType(JavaCompile).configureEach {
    it.options.release = 21
}

tasks.named('jar', Jar) {
    manifest {
        attributes(
                'Multi-Release': 'true',
                'Sealed': 'true',
                'Main-Class': 'gg.darkutils.DarkUtils',
                'Automatic-Module-Name': 'gg.darkutils',
                'Specification-Title': 'DarkUtils',
                'Specification-Version': project.version.toString(),
                'Specification-Vendor': 'DarkUtils',
                'Implementation-Title': 'DarkUtils',
                'Implementation-Version': project.version.toString(),
                'Implementation-Vendor': 'DarkUtils',
                'Name': 'gg/darkutils/'
        )
    }
}

java {
    // Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
    // if it is present.
    // If you remove this line, sources will not be generated.
    withSourcesJar()

    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

jar {
    inputs.property 'archivesName', project.base.archivesName
    final def archiveName = inputs.properties.archivesName

    from('LICENSE') {
        rename { "${it}_${archiveName}" }
    }
}

// configure the maven publication
publishing {
    publications {
        create('mavenJava', MavenPublication) {
            artifactId = project.archives_base_name
            from components.java
        }
    }

    // See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
    repositories {
        // Add repositories to publish to here.
        // Notice: This block does NOT have the same function as the block in the top level.
        // The repositories here will be used for publishing your artifact, not for
        // retrieving dependencies.
    }
}

// Task class for full configuration-cache compatibility
@CacheableTask
abstract class CheckMethodSizesTask extends DefaultTask {
    @CompileClasspath
    @InputFiles
    abstract ConfigurableFileCollection getClassesDirectories()

    @OutputFile
    abstract RegularFileProperty getReportFile()

    @TaskAction
    void checkMethods() {
        final def thresholds = [huge: 8000, large: 2000, nonsmall: 325]
        final def issues = []

        getClassesDirectories().each { final File directory ->
            if (!directory.exists()) return

            directory.eachFileRecurse { final File file ->
                if (!file.name.endsWith('.class')) return

                final def relativePath = directory.toPath().relativize(file.toPath()).toString()
                final def className = relativePath.replace(File.separator, '.').replaceAll('[.]class$', '')

                file.withInputStream { final inputStream ->
                    new DataInputStream(inputStream).withCloseable { final dataInputStream ->
                        final def classFile = new ClassFile(dataInputStream)
                        classFile.methods.each { final MethodInfo methodInfo ->
                            final def codeAttribute = methodInfo.codeAttribute
                            if (codeAttribute == null) return
                            final def size = codeAttribute.code.length

                            if (size > thresholds.huge) issues << "Huge method: $className#${methodInfo.name} (bytecode size: $size)"
                            else if (size > thresholds.large) issues << "Large method: $className#${methodInfo.name} (bytecode size: $size)"
                            else if (size > thresholds.nonsmall) issues << "Non trivial method: $className#${methodInfo.name} (bytecode size: $size)"
                        }
                    }
                }
            }
        }

        final def report = getReportFile().get().asFile
        report.parentFile.mkdirs()
        report.text = issues.join('\n')

        if (issues.empty) {
            println 'All methods are within size thresholds.'
        } else {
            println 'Method size issues found:'
            issues.each { println it }
            println "Method size check: ${issues.size()} issues"
        }
    }
}

// Register the task in a configuration-cache-safe way
tasks.register('checkMethodSizes', CheckMethodSizesTask) {
    group = 'verification'
    description = 'Checks bytecode sizes of compiled methods.'

    // Use a FileCollection as input (lazy, configuration-cache safe)
    classesDirectories.from(
        layout.buildDirectory.dir("classes/java/main")
    )

    reportFile.set(
        layout.buildDirectory.file("reports/methodSizes.txt")
    )

    dependsOn tasks.named('classes')
}

// Make it run after check
tasks.named('check') {
    finalizedBy tasks.named('checkMethodSizes')
}

static final Provider<File> resolveMinecraftDir(Project project) {
    final def providers = project.providers
    final def layout = project.layout

    final def devPropsFile = layout.projectDirectory.file('dev.properties')

    final Provider<String> fromProps =
            providers.fileContents(devPropsFile)
                    .asText
                    .map { text ->
                        final def props = new Properties()
                        props.load(new StringReader(text))
                        props.getProperty('minecraftDir')
                    }

    final def envFile = layout.projectDirectory.file('.env')

    final Provider<String> fromEnv =
            providers.fileContents(envFile)
                    .asText
                    .map { text ->
                        text.readLines()
                                .find { it.startsWith('MINECRAFT_DIR=') }
                                ?.split('=', 2)
                                ?.getAt(1)
                    }

    final Provider<String> defaultDir =
            providers.systemProperty('user.home')
                    .map { it + '/.minecraft' }

    final Provider<String> finalPath =
            fromProps
                    .orElse(fromEnv)
                    .orElse(defaultDir)

    return finalPath.map { new File(it) }
}

abstract class InstallToModFolderTask extends DefaultTask {
    @Classpath
    @InputFile
    abstract RegularFileProperty getInputJar()

    @Input
    abstract Property<String> getModVersion()

    @OutputDirectory
    abstract DirectoryProperty getTargetModsDir()

    @Inject
    abstract FileSystemOperations getFs()

    @TaskAction
    final void install() {
        final def input = getInputJar().get().asFile.toPath()
        final def modsDir = getTargetModsDir().get().asFile.toPath()

        if (!Files.exists(modsDir)) return

        final def fileName = input.fileName.toString()
        final def baseName =
                fileName.replaceFirst("-${getModVersion().get()}\\.jar\$", '')

        // Delete previous versions of this mod
        Files.list(modsDir)
                .filter { it.fileName.toString().startsWith(baseName + '-') }
                .filter { it.fileName.toString().endsWith('.jar') }
                .forEach {
                    logger.lifecycle("Removing old mod jar: ${it.fileName}")
                    Files.deleteIfExists(it)
                }

        final def target = modsDir.resolve(fileName)

        Files.copy(
                input,
                target,
                StandardCopyOption.REPLACE_EXISTING
        )

        logger.lifecycle('DarkUtils jar installed successfully:')
        logger.lifecycle("${fileName} -> ${modsDir}")
        logger.lifecycle('')
        logger.lifecycle('You do not need to copy manually to your mod folder.')
    }
}

tasks.register('installToModFolder', InstallToModFolderTask) {
    dependsOn tasks.named('remapJar')

    inputJar.set(
        tasks.named('remapJar').flatMap { it.archiveFile }
    )

    modVersion.set(project.version.toString())

    targetModsDir.set(
            project.layout.dir(
                    resolveMinecraftDir(project)
                            .map { new File(it, 'mods') }
            )
    )
}

tasks.named('checkMethodSizes') {
    finalizedBy tasks.named('installToModFolder')
}

tasks.named('installToModFolder', InstallToModFolderTask).configure {
    onlyIf(new Spec<Task>() {
        @Override
        boolean isSatisfiedBy(final Task t) {
            final def dir = ((InstallToModFolderTask) t)
                    .getTargetModsDir()
                    .getOrNull()

            return null == System.getenv('CI') &&
                   null != dir &&
                   dir.getAsFile().exists()
        }
    })
}

